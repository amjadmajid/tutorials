#include <msp430fr5969.h>

#define __nv  __attribute__((section(".rodata")))

__nv unsigned char data [256] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x10, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x20, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x30, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x40, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x60, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x70, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x80, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0x90, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xA0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xB0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xC0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xD0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xE0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
        0xF0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};

/*
 * main.c
 */
int main(void) {
    WDTCTL = WDTPW | WDTHOLD;   // Stop watchdog timer

    P2SEL1 |= BIT4 | BIT5 | BIT6;            // USCI_A1 operation
    PJSEL0 |= (BIT5 + BIT4);   // LF

    PM5CTL0 &= ~LOCKLPM5;

    CSCTL0_H = CSKEY >> 8;                    // Unlock CS registers
    CSCTL1 = DCOFSEL_6;                           // 8MHz
    CSCTL2 = SELA__LFXTCLK | SELS__DCOCLK | SELM__DCOCLK;   // ACLK Source Select LFXTCLK; Set SMCLK = MCLK = DCO
    CSCTL3 = DIVA__1 | DIVS__1 | DIVM__1;     // Set dividers to 1  except SMCLK: /8
    CSCTL4 &= ~LFXTOFF;

    __delay_cycles(1000);
    do
    {
        CSCTL5 &= ~(LFXTOFFG + HFXTOFFG);                    // Clear XT1 fault flag
        SFRIFG1 &= ~OFIFG;
    }while (SFRIFG1&OFIFG);                   // Test oscillator fault flag
    CSCTL0_H = 0;

    // Configure USCI_A1 for SPI operation
    UCA1CTLW0 = UCSWRST;                      // **Put state machine in reset**
    UCA1CTLW0 |= UCMST | UCSYNC | UCCKPL | UCMSB; // 3-pin, 8-bit SPI master
                                              // Clock polarity high, MSB
    UCA1CTLW0 |= UCSSEL__SMCLK;               // SMCLK
    UCA1BR0 = 0x02;                           // /2
    UCA1BR1 = 0;                              //
    UCA1MCTLW = 0;                            // No modulation
    UCA1CTLW0 &= ~UCSWRST;                    // **Initialize USCI state machine**
    UCA1IE &= ~UCRXIE;                         // Disable USCI_A0 RX interrupt

    /* Clear any pending flags */
    UCA1IFG &= ~(UCRXIFG);

    /* Get the block */
    /* Source DMA address: the data buffer. */
    // Configure DMA channel 0
    __data16_write_addr((unsigned short) &DMA0SA,(unsigned long) &data);
                                              // Source block address
    __data16_write_addr((unsigned short) &DMA0DA,(unsigned long) &UCA1TXBUF);
                                              // Destination single address
    /* The size of the block to be transferred */
    DMA0SZ = 256;

    /* DMA trigger is SPI send */
    DMACTL0 = DMA0TSEL__UCA1TXIFG;

    /* Configure the DMA transfer*/
    DMA0CTL =
    DMADT_0 | /* Single transfer mode */
    DMADSTBYTE | /* source Byte mode */
    DMASRCBYTE | /* dest Byte mode */
    DMAEN | /* Enable DMA */
    DMAIE | /* DMA interrupt enable */
    DMALEVEL |
    DMASRCINCR1 | DMASRCINCR0; /* Increment the source address */

    __bis_SR_register(LPM4_bits + GIE);       // Enter LPM3 w/ interrupts

    while(1)
    {
        __no_operation();
    }
}

void __attribute__((interrupt(DMA_VECTOR))) DMA_ISR(void)
{
    long val;

    val = DMAIV;

    __delay_cycles(100);

    DMA0CTL |= DMAEN;                         // DMA0 Enable
}
